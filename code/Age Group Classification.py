# -*- coding: utf-8 -*-
"""Copy of Age group Classification

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y9xdSwBYDMUZgLWauC_MwZK63yb1S4UV
"""

from google.colab import drive
drive.mount('/content/drive/')

!unzip '/content/drive/MyDrive/Age Group Identification/age_group_classification_dataset.zip'

import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import seaborn as sns
import keras
import pandas as pd
import numpy as np
from keras.models import Model, Sequential,load_model
from keras.layers import Dense, Conv2D , MaxPool2D , Flatten , Dropout , BatchNormalization, GlobalAveragePooling2D
from keras.preprocessing.image import ImageDataGenerator,img_to_array
from keras.applications.vgg16 import VGG16, preprocess_input
from keras.applications.inception_v3 import InceptionV3
from keras.applications import Xception
from keras.applications import DenseNet121, DenseNet169, DenseNet201
from keras.optimizers import Adam, RMSprop,SGD
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report,confusion_matrix,accuracy_score
from PIL import Image
import cv2
import os
import glob
import itertools

directory = "/content/Age_classification dataset"
folders = os.listdir(directory)
print(folders)

image_names = []
size = (224,224)

dataset_labels = []
dataset = []
for folder in folders:
    for file in os.listdir(os.path.join(directory,folder)):
          image_names.append(os.path.join(directory,folder,file))
          dataset_labels.append(folder)
          img = cv2.imread(os.path.join(directory,folder,file))
          # resize image
          img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)
          im = cv2.resize(img,size,interpolation = cv2.INTER_CUBIC)
          dataset.append(im)

label_dummies = pd.get_dummies(dataset_labels)
labels =  label_dummies.values.argmax(1)
print(pd.unique(dataset_labels))
print(pd.unique(labels))


# Convert the shuffled list to numpy array type

dataset = np.array(dataset)
labels = np.array(labels)

print ("total dataset shape",dataset.shape)
print ("total Labels shape",labels.shape)

# normalize dataset
dataset = dataset.astype('float32') 
dataset /= 255

X_train,X_test,Y_train,Y_test=train_test_split(dataset,labels,test_size=0.1,random_state = 3, shuffle=True)

print("x train=",X_train.shape)
print("y train=",Y_train.shape)

print("x test=",X_test.shape)
print("y test=",Y_test.shape)

datagen = ImageDataGenerator(
        rotation_range=10,  # randomly rotate images in the range (degrees, 0 to 180)
        width_shift_range=0.2,  # randomly shift images horizontally (fraction of total width)
        height_shift_range=0.2,  # randomly shift images vertically (fraction of total height)
        horizontal_flip=True,  # randomly flip images
        vertical_flip=True, # randomly flip images
        fill_mode = 'nearest')  

datagen.fit(X_train)

"""# Fine Tune InceptionResnetV2 Network"""

from keras.applications import InceptionResNetV2

base_model2 = InceptionResNetV2( weights = 'imagenet',include_top = False, input_shape = (224,224,3))

base_model2.summary()

for i, layer in enumerate(base_model2.layers):
    print(i, layer.name)

NUM_CLASSES = 8

model2 = Sequential()
model2.add(base_model2)
model2.add(Flatten())
model2.add(Dense(1024, activation = 'relu'))
model2.add(Dense(512,activation = 'relu'))
model2.add(Dense(256,activation = 'relu'))
model2.add(Dropout(0.5))
#model2.add(Dense(128,activation = 'relu'))
model2.add(Dense(NUM_CLASSES, activation='softmax'))

for layer in base_model2.layers:
    layer.trainable = False

model2.compile(
    loss='sparse_categorical_crossentropy',
    optimizer=Adam(lr=1e-4),
    metrics=['accuracy']
)

model2.summary()

epochs = 10
batch_size = 32
history = model2.fit_generator(datagen.flow(X_train,Y_train, batch_size=batch_size),
                              epochs = epochs, validation_data = (X_test,Y_test),
                              verbose = 1, steps_per_epoch=X_train.shape[0] // batch_size)

for layer in base_model2.layers[:287]:
    layer.trainable = False
for layer in base_model2.layers[287:]:
    layer.trainable = True

NUM_CLASSES = 8

model3 = Sequential()
model3.add(base_model2)
model3.add(Flatten())
model3.add(Dense(1024, activation = 'relu'))
model3.add(Dense(512,activation = 'relu'))
model3.add(Dense(256,activation = 'relu'))
#model3.add(Dense(128,activation = 'relu'))
model3.add(Dropout(0.5))
model3.add(Dense(NUM_CLASSES, activation='softmax'))

model3.compile(
    loss='sparse_categorical_crossentropy',
    optimizer=Adam(lr=1e-4),
    metrics=['accuracy']
)

model3.summary()

epochs = 15
batch_size = 32
history = model3.fit_generator(datagen.flow(X_train,Y_train, batch_size=batch_size),
                              epochs = epochs, validation_data = (X_test,Y_test),
                              verbose = 1, steps_per_epoch=X_train.shape[0] // batch_size)

acc = history.history['accuracy']
val_acc = history.history['val_accuracy']
loss = history.history['loss']
val_loss = history.history['val_loss']
epochs_range = range(1, len(history.epoch) + 1)

plt.figure(figsize=(15,5))

plt.subplot(1, 2, 1)
plt.plot(epochs_range, acc, label='Train Set')
plt.plot(epochs_range, val_acc, label='Val Set')
plt.legend(loc="best")
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.title('Model Accuracy')

plt.subplot(1, 2, 2)
plt.plot(epochs_range, loss, label='Train Set')
plt.plot(epochs_range, val_loss, label='Val Set')
plt.legend(loc="best")
plt.xlabel('Epochs')

plt.tight_layout()
plt.show()

epochs = 2
batch_size = 32
history = model3.fit_generator(datagen.flow(X_train,Y_train, batch_size=batch_size),
                              epochs = epochs, validation_data = (X_test,Y_test),
                              verbose = 1, steps_per_epoch=X_train.shape[0] // batch_size)

pred=model3.predict(X_test)
y_pred=np.argmax(pred,axis=1)
loss, acc = model3.evaluate(X_test, Y_test, verbose = 0)
print("\nEvaluation on test data: ", acc * 100)

def plot_confusion_matrix(cm,
                          target_names,
                          title='Confusion matrix',
                          cmap=None,
                          normalize=True):
    """
    given a sklearn confusion matrix (cm), make a nice plot

    Arguments
    ---------
    cm:           confusion matrix from sklearn.metrics.confusion_matrix

    target_names: given classification classes such as [0, 1, 2]
                  the class names, for example: ['high', 'medium', 'low']

    title:        the text to display at the top of the matrix

    cmap:         the gradient of the values displayed from matplotlib.pyplot.cm
                  see http://matplotlib.org/examples/color/colormaps_reference.html
                  plt.get_cmap('jet') or plt.cm.Blues

    normalize:    If False, plot the raw numbers
                  If True, plot the proportions

    Usage
    -----
    plot_confusion_matrix(cm           = cm,                  # confusion matrix created by
                                                              # sklearn.metrics.confusion_matrix
                          normalize    = True,                # show proportions
                          target_names = y_labels_vals,       # list of names of the classes
                          title        = best_estimator_name) # title of graph

    Citiation
    ---------
    http://scikit-learn.org/stable/auto_examples/model_selection/plot_confusion_matrix.html

    """
    import matplotlib.pyplot as plt
    import numpy as np
    import itertools

    accuracy = np.trace(cm) / float(np.sum(cm))
    misclass = 1 - accuracy

    if cmap is None:
        cmap = plt.get_cmap('Blues')

    plt.figure(figsize=(8, 6))
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()

    if target_names is not None:
        tick_marks = np.arange(len(target_names))
        plt.xticks(tick_marks, target_names, rotation=45)
        plt.yticks(tick_marks, target_names)

    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]


    thresh = cm.max() / 1.5 if normalize else cm.max() / 2
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        if normalize:
            plt.text(j, i, "{:0.4f}".format(cm[i, j]),
                     horizontalalignment="center",
                     color="white" if cm[i, j] > thresh else "black")
        else:
            plt.text(j, i, "{:,}".format(cm[i, j]),
                     horizontalalignment="center",
                     color="white" if cm[i, j] > thresh else "black")


    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label\naccuracy={:0.4f}; misclass={:0.4f}'.format(accuracy, misclass))
    plt.show()

confusion_mtx = confusion_matrix(Y_test, y_pred)
cm_plot_labels = ['15-20', '4-6', '60-100', '0-2', '38-43', '25-32', '48-53', '8-12']
cm = plot_confusion_matrix(confusion_mtx, target_names = cm_plot_labels, normalize=False)

model3.save ("/content/drive/MyDrive/Age Group Identification/saved model/model_inceptionResnetv2.h5")

"""# Application Phase"""

file_path = '/content/drive/MyDrive/Age Group Identification/girl2.jfif'
input_image  = cv2.imread(file_path)

resized_image = cv2.resize(input_image, (224, 224), interpolation = cv2.INTER_CUBIC)
rgb_image = cv2.cvtColor(resized_image, cv2.COLOR_BGR2RGB)
image = np.array(rgb_image)
image  = image.astype('float32') 
image= image/ 255

model = load_model('/content/drive/MyDrive/Age Group Identification/saved model/model_inceptionResnetv2.h5')

classes = { 
    0:'0-2',
    1:'15-20',
    2:'25-32',
    3:'38-43',
    4:'4-6',
    5:'48-53',
    6:'60-100',
    7:'8-12'
}

image = np.expand_dims(image, axis=0)
pred = model.predict_classes([image])[0]
sign = classes[pred]
print(sign)

plt.imshow(rgb_image)
plt.xticks([]), plt.yticks([])  # to hide tick values on X and Y axis
plt.show()